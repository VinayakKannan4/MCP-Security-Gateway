"""Approval token lifecycle manager.

Tokens are stored in two places:
- Redis (fast read path, TTL-bound): key = "approval:{token}"
- Postgres (durable fallback): survives Redis eviction

Security invariants:
- Redis TTL is always set — tokens cannot accumulate indefinitely.
- approve() / deny() validate against Postgres (authoritative), not Redis.
- After a decision, the Redis key is deleted to force Postgres reads.
- Tokens are cryptographically random (secrets.token_urlsafe(32)) and
  generated by ApprovalRequest.token's default_factory — not here.
"""

import logging
from datetime import datetime

from redis.asyncio import Redis
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from gateway.cache.redis_client import delete, get_json, set_json
from gateway.config import settings
from gateway.db.models import ApprovalRequestRow
from gateway.models.approval import ApprovalRequest, ApprovalResult, ApprovalStatus

logger = logging.getLogger(__name__)

_KEY_PREFIX = "approval:"


class ApprovalManager:
    def __init__(self, session: AsyncSession, redis: Redis[str]) -> None:
        self._session = session
        self._redis = redis

    async def issue_token(self, request: ApprovalRequest) -> str:
        """Store a new approval request in Redis (with TTL) and Postgres (durable).

        Returns the token string from the request.
        """
        key = f"{_KEY_PREFIX}{request.token}"

        # 1. Store in Redis with TTL — fast path for polling agents
        await set_json(
            self._redis,
            key,
            request.model_dump(mode="json"),
            ttl=settings.approval_token_ttl_seconds,
        )

        # 2. Store in Postgres for durability
        row = ApprovalRequestRow(
            token=request.token,
            request_id=request.request_id,
            caller_id=request.caller_id,
            tool_call=request.tool_call.model_dump(),
            risk_explanation=request.risk_explanation,
            created_at=request.created_at,
            expires_at=request.expires_at,
            status=request.status.value,
            approver_id=request.approver_id,
            decision_at=request.decision_at,
            approver_note=request.approver_note,
        )
        self._session.add(row)
        await self._session.commit()

        logger.debug("approval token issued request_id=%s", request.request_id)
        return request.token

    async def check_token(self, token: str) -> ApprovalResult:
        """Return the current status of an approval token.

        Checks Redis first (fast path). Falls back to Postgres if the key has
        been evicted or was never stored in Redis (e.g. after a decision).

        Raises ValueError if the token is not found in either store.
        """
        key = f"{_KEY_PREFIX}{token}"

        # Fast path: Redis
        data = await get_json(self._redis, key)
        if data is not None:
            decided_at_raw = data.get("decision_at")
            return ApprovalResult(
                token=token,
                status=ApprovalStatus(data["status"]),
                approver_id=data.get("approver_id"),
                note=data.get("approver_note"),
                decided_at=(
                    datetime.fromisoformat(decided_at_raw) if decided_at_raw else None
                ),
            )

        # Fallback: Postgres
        result = await self._session.execute(
            select(ApprovalRequestRow).where(ApprovalRequestRow.token == token)
        )
        row = result.scalar_one_or_none()
        if row is None:
            raise ValueError(f"Approval token not found: {token!r}")

        return ApprovalResult(
            token=token,
            status=ApprovalStatus(row.status),
            approver_id=row.approver_id,
            note=row.approver_note,
            decided_at=row.decision_at,
        )

    async def approve(self, token: str, approver_id: str, note: str = "") -> ApprovalResult:
        """Approve a pending token. Raises ValueError if not found or already decided."""
        return await self._set_decision(token, ApprovalStatus.APPROVED, approver_id, note)

    async def deny(self, token: str, approver_id: str, note: str = "") -> ApprovalResult:
        """Deny a pending token. Raises ValueError if not found or already decided."""
        return await self._set_decision(token, ApprovalStatus.DENIED, approver_id, note)

    async def _set_decision(
        self,
        token: str,
        new_status: ApprovalStatus,
        approver_id: str,
        note: str,
    ) -> ApprovalResult:
        """Apply an APPROVED or DENIED decision to a PENDING token.

        Validates current state from Postgres (authoritative), updates Postgres,
        then deletes the Redis key so future check_token calls read from Postgres.
        """
        # Validate against Postgres — the authoritative source of truth
        result = await self._session.execute(
            select(ApprovalRequestRow).where(ApprovalRequestRow.token == token)
        )
        row = result.scalar_one_or_none()
        if row is None:
            raise ValueError(f"Approval token not found: {token!r}")
        if row.status != ApprovalStatus.PENDING.value:
            raise ValueError(f"Token already decided with status: {row.status!r}")

        now = datetime.utcnow()

        # Update Postgres
        await self._session.execute(
            update(ApprovalRequestRow)
            .where(ApprovalRequestRow.token == token)
            .values(
                status=new_status.value,
                approver_id=approver_id,
                approver_note=note or None,
                decision_at=now,
            )
        )
        await self._session.commit()

        # Invalidate Redis — next check_token will read the updated row from Postgres
        await delete(self._redis, f"{_KEY_PREFIX}{token}")

        logger.debug(
            "approval decision token=*** status=%s approver=%s", new_status.value, approver_id
        )
        return ApprovalResult(
            token=token,
            status=new_status,
            approver_id=approver_id,
            note=note or None,
            decided_at=now,
        )
